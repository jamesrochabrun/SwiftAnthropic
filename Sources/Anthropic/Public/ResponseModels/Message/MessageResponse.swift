//
//  MessageResponse.swift
//
//
//  Created by James Rochabrun on 1/28/24.
//

import Foundation

/// [Message Response](https://docs.anthropic.com/claude/reference/messages_post)
public struct MessageResponse: Decodable {
  /// Unique object identifier.
  ///
  /// The format and length of IDs may change over time.
  public let id: String?
  
  /// e.g: "message"
  public let type: String?
  
  /// The model that handled the request.
  public let model: String?
  
  /// Conversational role of the generated message.
  ///
  /// This will always be "assistant".
  public let role: String
  
  /// Array of Content objects representing blocks of content generated by the model.
  ///
  /// Each content block has a `type` that determines its structure.
  ///
  /// - Example text:
  ///   ```
  ///   [{"type": "text", "text": "Hi, I'm Claude."}]
  ///   ```
  ///
  /// - Example thinking:
  ///   ```
  ///   [{"type": "thinking", "thinking": "To approach this, let's think about...", "signature": "zbbJhb..."}]
  ///   ```
  ///
  /// - Example tool use:
  ///   ```
  ///   [{"type": "tool_use", "id": "toolu_01A09q90qw90lq917835lq9", "name": "get_weather", "input": { "location": "San Francisco, CA", "unit": "celsius"}}]
  ///   ```
  /// This structure facilitates the integration and manipulation of model-generated content within your application.
  public let content: [Content]
  
  /// indicates why the process was halted.
  ///
  /// This property can hold one of the following values to describe the stop reason:
  /// - `"end_turn"`: The model reached a natural stopping point.
  /// - `"max_tokens"`: The requested `max_tokens` limit or the model's maximum token limit was exceeded.
  /// - `"stop_sequence"`: A custom stop sequence provided by you was generated.
  ///
  /// It's important to note that the values for `stopReason` here differ from those in `/v1/complete`, specifically in how `end_turn` and `stop_sequence` are distinguished.
  ///
  /// - In non-streaming mode, `stopReason` is always non-null, indicating the reason for stopping.
  /// - In streaming mode, `stopReason` is null in the `message_start` event and non-null in all other cases, providing context for the stoppage.
  ///
  /// This design allows for a detailed understanding of the process flow and its termination points.
  public let stopReason: String?
  
  /// Which custom stop sequence was generated.
  ///
  /// This value will be non-null if one of your custom stop sequences was generated.
  public let stopSequence: String?

  /// Container for the number of tokens used.
  public let usage: Usage

  /// Container information when skills are used.
  /// Contains the container ID that can be reused in subsequent requests.
  public let container: ContainerInfo?

  /// Container information returned in responses when skills are used
  public struct ContainerInfo: Decodable {
    /// The container ID that can be reused across multiple messages
    public let id: String?
  }

  public enum Content: Codable {
    public typealias Input = [String: DynamicContent]
    public typealias Citations = [Citation]
    
    public struct ToolUse: Codable {
      public let id: String
      public let name: String
      public let input: Input
    }
    
    public struct Thinking: Codable {
      public let thinking: String
      public let signature: String?
    }
    
    public struct ServerToolUse: Codable {
      public let id: String
      public let input: Input
      public let type: String
      public let name: String
    }
    
    public struct ToolResult: Codable {
      public let content: ToolResultContent
      public let isError: Bool?
      public let toolUseId: String?
    }
    
    public struct WebSearchToolResult: Codable {
      public let toolUseId: String?
      public let content: [ContentItem]
      public let type: String
      
      private enum CodingKeys: String, CodingKey {
        case toolUseId = "tool_use_id"
        case content
        case type
      }
    }
    
    case text(String, Citations?)
    case toolUse(ToolUse)
    case thinking(Thinking)
    case serverToolUse(ServerToolUse)
    case webSearchToolResult(WebSearchToolResult)
    case toolResult(ToolResult)
    
    private enum CodingKeys: String, CodingKey {
      case type, text, id, name, input, citations, thinking, signature
      case toolUseId = "tool_use_id"
      case content
      case isError
    }
    
    public enum DynamicContent: Codable {
      case string(String)
      case integer(Int)
      case double(Double)
      case dictionary(Input)
      case array([DynamicContent])
      case bool(Bool)
      case null
      
      public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let intValue = try? container.decode(Int.self) {
          self = .integer(intValue)
        } else if let doubleValue = try? container.decode(Double.self) {
          self = .double(doubleValue)
        } else if let stringValue = try? container.decode(String.self) {
          self = .string(stringValue)
        } else if let boolValue = try? container.decode(Bool.self) {
          self = .bool(boolValue)
        } else if container.decodeNil() {
          self = .null
        } else if let arrayValue = try? container.decode([DynamicContent].self) {
          self = .array(arrayValue)
        } else if let dictionaryValue = try? container.decode([String: DynamicContent].self) {
          self = .dictionary(dictionaryValue)
        } else {
          throw DecodingError.dataCorruptedError(in: container, debugDescription: "Content cannot be decoded")
        }
      }
      
      public func encode(to encoder: any Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let val):
          try container.encode(val)
        case .integer(let val):
          try container.encode(val)
        case .double(let val):
          try container.encode(val)
        case .dictionary(let val):
          try container.encode(val)
        case .array(let val):
          try container.encode(val)
        case .bool(let val):
          try container.encode(val)
        case .null:
          try container.encodeNil()
        }
      }
    }
    
    public init(from decoder: Decoder) throws {
      let container = try decoder.container(keyedBy: CodingKeys.self)
      let type = try container.decode(String.self, forKey: .type)
      switch type {
      case "text":
        let text = try container.decode(String.self, forKey: .text)
        let citations = try container.decodeIfPresent(Citations.self, forKey: .citations)
        self = .text(text, citations)
      case "tool_use":
        let id = try container.decode(String.self, forKey: .id)
        let name = try container.decode(String.self, forKey: .name)
        let input = try container.decode(Input.self, forKey: .input)
        self = .toolUse(ToolUse(id: id, name: name, input: input))
      case "thinking":
        let thinking = try container.decode(String.self, forKey: .thinking)
        let signature = try container.decodeIfPresent(String.self, forKey: .signature)
        self = .thinking(Thinking(thinking: thinking, signature: signature))
      case "server_tool_use":
        let id = try container.decode(String.self, forKey: .id)
        let name = try container.decode(String.self, forKey: .name)
        let input = try container.decode(Input.self, forKey: .input)
        let type = try container.decode(String.self, forKey: .type)
        self = .serverToolUse(ServerToolUse(id: id, input: input, type: type, name: name))
      case "web_search_tool_result":
        let toolUseId = try container.decodeIfPresent(String.self, forKey: .toolUseId)
        let content = try container.decode([ContentItem].self, forKey: .content)
        let type = try container.decode(String.self, forKey: .type)
        self = .webSearchToolResult(WebSearchToolResult(toolUseId: toolUseId, content: content, type: type))
      case "tool_result":
        let toolUseId = try container.decodeIfPresent(String.self, forKey: .toolUseId)
        let isError = try container.decodeIfPresent(Bool.self, forKey: .isError) ?? false

        // Now decode the flexible content type
        let content = try container.decode(ToolResultContent.self, forKey: .content)
        self = .toolResult(ToolResult(content: content, isError: isError, toolUseId: toolUseId))
      default:
        throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Invalid type value found in JSON!")
      }
    }
    
    public func encode(to encoder: any Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      switch self {
      case .text(let text, let citations):
        try container.encode("text", forKey: .type)
        try container.encode(text, forKey: .text)
        try container.encodeIfPresent(citations, forKey: .citations)
      case .toolUse(let toolUse):
        try container.encode("tool_use", forKey: .type)
        try container.encode(toolUse.id, forKey: .id)
        try container.encode(toolUse.name, forKey: .name)
        try container.encode(toolUse.input, forKey: .input)
      case .thinking(let thinking):
        try container.encode("thinking", forKey: .type)
        try container.encode(thinking.thinking, forKey: .thinking)
        try container.encodeIfPresent(thinking.signature, forKey: .signature)
      case .serverToolUse(let serverToolUse):
        try container.encode("server_tool_use", forKey: .type)
        try container.encode(serverToolUse.id, forKey: .id)
        try container.encode(serverToolUse.name, forKey: .name)
        try container.encode(serverToolUse.input, forKey: .input)
      case .webSearchToolResult(let webSearchResult):
        try container.encode("web_search_tool_result", forKey: .type)
        try container.encode(webSearchResult.toolUseId, forKey: .toolUseId)
        try container.encode(webSearchResult.content, forKey: .content)
      case .toolResult(let toolResult):
        try container.encode("tool_result", forKey: .type)
        try container.encode(toolResult.content, forKey: .content)
        try container.encodeIfPresent(toolResult.isError, forKey: .isError)
        try container.encodeIfPresent(toolResult.toolUseId, forKey: .toolUseId)
      }
    }
  }
  
  /// Claude is capable of providing detailed citations when answering questions about documents, helping you track and verify information sources in responses.
  /// https://docs.anthropic.com/en/docs/build-with-claude/citations
  public enum Citation: Codable {
    case charLocation(CharLocation)
    case pageLocation(PageLocation)
    case contentBlockLocation(ContentBlockLocation)
    case webSearchResultLocation(WebSearchResultLocation)
    
    private enum CodingKeys: String, CodingKey {
      case type
      case citedText
      case documentIndex
      case documentTitle
      case startCharIndex
      case endCharIndex
      case startPageNumber
      case endPageNumber
      case startBlockIndex
      case endBlockIndex
      case url
      case title
      case encryptedIndex
    }
    
    public struct CharLocation: Codable {
      public let citedText: String?
      public let documentIndex: Int?
      public let documentTitle: String?
      public let startCharIndex: Int?
      public let endCharIndex: Int?
    }
    
    public struct PageLocation: Codable {
      public let citedText: String?
      public let documentIndex: Int?
      public let documentTitle: String?
      public let startPageNumber: Int?
      public let endPageNumber: Int?
    }
    
    public struct ContentBlockLocation: Codable {
      public let citedText: String?
      public let documentIndex: Int?
      public let documentTitle: String?
      public let startBlockIndex: Int?
      public let endBlockIndex: Int?
    }
    
    public struct WebSearchResultLocation: Codable {
      public let url: String?
      public let title: String?
      public let encryptedIndex: String?
      public let citedText: String?
    }
    
    public init(from decoder: Decoder) throws {
      let container = try decoder.container(keyedBy: CodingKeys.self)
      let type = try container.decode(String.self, forKey: .type)
      
      switch type {
      case "char_location":
        self = .charLocation(CharLocation(
          citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
          documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
          documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
          startCharIndex: try container.decodeIfPresent(Int.self, forKey: .startCharIndex),
          endCharIndex: try container.decodeIfPresent(Int.self, forKey: .endCharIndex)
        ))
      case "page_location":
        self = .pageLocation(PageLocation(
          citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
          documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
          documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
          startPageNumber: try container.decodeIfPresent(Int.self, forKey: .startPageNumber),
          endPageNumber: try container.decodeIfPresent(Int.self, forKey: .endPageNumber)
        ))
      case "content_block_location":
        self = .contentBlockLocation(ContentBlockLocation(
          citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
          documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
          documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
          startBlockIndex: try container.decodeIfPresent(Int.self, forKey: .startBlockIndex),
          endBlockIndex: try container.decodeIfPresent(Int.self, forKey: .endBlockIndex)
        ))
      case "web_search_result_location":
        self = .webSearchResultLocation(WebSearchResultLocation(
          url: try container.decodeIfPresent(String.self, forKey: .url),
          title: try container.decodeIfPresent(String.self, forKey: .title),
          encryptedIndex: try container.decodeIfPresent(String.self, forKey: .encryptedIndex),
          citedText: try container.decodeIfPresent(String.self, forKey: .citedText)
        ))
      default:
        throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Invalid citation type!")
      }
    }
    
    public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      
      switch self {
      case .charLocation(let location):
        try container.encode("char_location", forKey: .type)
        try container.encodeIfPresent(location.citedText, forKey: .citedText)
        try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
        try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
        try container.encodeIfPresent(location.startCharIndex, forKey: .startCharIndex)
        try container.encodeIfPresent(location.endCharIndex, forKey: .endCharIndex)
      case .pageLocation(let location):
        try container.encode("page_location", forKey: .type)
        try container.encodeIfPresent(location.citedText, forKey: .citedText)
        try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
        try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
        try container.encodeIfPresent(location.startPageNumber, forKey: .startPageNumber)
        try container.encodeIfPresent(location.endPageNumber, forKey: .endPageNumber)
      case .contentBlockLocation(let location):
        try container.encode("content_block_location", forKey: .type)
        try container.encodeIfPresent(location.citedText, forKey: .citedText)
        try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
        try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
        try container.encodeIfPresent(location.startBlockIndex, forKey: .startBlockIndex)
        try container.encodeIfPresent(location.endBlockIndex, forKey: .endBlockIndex)
      case .webSearchResultLocation(let location):
        try container.encode("web_search_result_location", forKey: .type)
        try container.encodeIfPresent(location.url, forKey: .url)
        try container.encodeIfPresent(location.title, forKey: .title)
        try container.encodeIfPresent(location.encryptedIndex, forKey: .encryptedIndex)
        try container.encodeIfPresent(location.citedText, forKey: .citedText)
      }
    }
  }
  
  public struct Usage: Codable {
    /// The number of input tokens which were used.
    public let inputTokens: Int?
    
    /// The number of output tokens which were used.
    public let outputTokens: Int
    
    /// The number of thinking tokens which were used (when thinking mode is enabled).
    public let thinkingTokens: Int?
    
    /// [Prompt Caching](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching#how-can-i-track-the-effectiveness-of-my-caching-strategy)
    /// You can monitor cache performance using the cache_creation_input_tokens and cache_read_input_tokens fields in the API response.
    public let cacheCreationInputTokens: Int?
    
    /// [Prompt Caching](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching#how-can-i-track-the-effectiveness-of-my-caching-strategy)
    /// You can monitor cache performance using the cache_creation_input_tokens and cache_read_input_tokens fields in the API response.
    public let cacheReadInputTokens: Int?
    
    /// Server tool usage information - NEW
    public let serverToolUse: ServerToolUse?
  }
  
  public struct ServerToolUse: Codable {
    /// Number of web search requests performed
    public let webSearchRequests: Int?
  }
}

/// Extension to provide convenient access to thinking content
extension MessageResponse {
  
  /// Extracts all thinking content blocks from the response
  /// - Returns: Array of thinking content or empty array if none found
  public func getThinkingContent() -> [Content.Thinking] {
    return content.compactMap { contentBlock in
      if case .thinking(let thinking) = contentBlock {
        return thinking
      }
      return nil
    }
  }
  
  /// Get the first thinking content block from the response
  /// - Returns: The first thinking content block or nil if none exists
  public func getFirstThinkingContent() -> Content.Thinking? {
    return getThinkingContent().first
  }
  
  /// Get the combined thinking content as a single string
  /// - Returns: All thinking content concatenated into a single string, or nil if no thinking content exists
  public func getCombinedThinkingContent() -> String? {
    let thinkingBlocks = getThinkingContent()
    if thinkingBlocks.isEmpty {
      return nil
    }
    
    return thinkingBlocks.map { $0.thinking }.joined(separator: "\n\n")
  }
  
  /// Determines if the response contains any thinking content
  /// - Returns: True if thinking content exists, false otherwise
  public var hasThinkingContent: Bool {
    return content.contains { contentBlock in
      if case .thinking = contentBlock {
        return true
      }
      return false
    }
  }
}

// MARK: MessageResponse.Content + DynamicContent

public extension MessageResponse.Content.DynamicContent {
  var stringValue: String? {
    if case .string(let value) = self {
      return value
    }
    return nil
  }
  
  var intValue: Int? {
    if case .integer(let value) = self {
      return value
    }
    return nil
  }
  
  var boolValue: Bool? {
    if case .bool(let value) = self {
      return value
    }
    return nil
  }
  
  var arrayValue: [MessageResponse.Content.DynamicContent]? {
    if case .array(let value) = self {
      return value
    }
    return nil
  }
  
  var dictionaryValue: [String: MessageResponse.Content.DynamicContent]? {
    if case .dictionary(let value) = self {
      return value
    }
    return nil
  }
}

// MARK: MessageResponse.Content + TextEditorCommand

public extension MessageResponse.Content {
  
  enum TextEditorCommand: String {
    case view
    case str_replace
    case insert
    case create
    case undo_edit
    
    // Helper to extract command from input
    public static func from(_ input: [String: DynamicContent]) -> TextEditorCommand? {
      guard let commandValue = input["command"]?.stringValue else { return nil }
      return TextEditorCommand(rawValue: commandValue)
    }
  }
}

// MARK: MessageResponse.Content + ToolResultContent

public extension MessageResponse.Content {
  
  public enum ToolResultContent: Codable {
    case string(String)
    case items([ContentItem])
    
    public init(from decoder: Decoder) throws {
      let container = try decoder.singleValueContainer()
      
      if let stringValue = try? container.decode(String.self) {
        self = .string(stringValue)
      } else if let itemsArray = try? container.decode([ContentItem].self) {
        self = .items(itemsArray)
      } else {
        throw DecodingError.dataCorruptedError(
          in: container,
          debugDescription: "ToolResultContent must be either String or [ContentItem]"
        )
      }
    }
    
    public func encode(to encoder: Encoder) throws {
      var container = encoder.singleValueContainer()
      
      switch self {
      case .string(let value):
        try container.encode(value)
      case .items(let items):
        try container.encode(items)
      }
    }
  }
}

// MARK: ContentItem

public struct ContentItem: Codable {
  public let encryptedContent: String?
  public let title: String?
  public let pageAge: String?
  public let type: String?
  public let url: String?
  public let text: String?
  
  var description: String {
    var result = "ContentItem:\n"
    
    if let title = self.title {
      result += "  Title: \"\(title)\"\n"
    }
    
    if let url = self.url {
      result += "  URL: \(url)\n"
    }
    
    if let type = self.type {
      result += "  Type: \(type)\n"
    }
    
    if let pageAge = self.pageAge {
      result += "  Age: \(pageAge)\n"
    }
    
    if let text = self.text {
      // Limit text length for readability
      let truncatedText = text.count > 100 ? "\(text.prefix(100))..." : text
      result += "  Text: \"\(truncatedText)\"\n"
    }
    
    if let encryptedContent = self.encryptedContent {
      // Just indicate presence rather than showing the whole encrypted content
      result += "  Encrypted Content: [Present]\n"
    }
    
    return result
  }
  
  private enum CodingKeys: String, CodingKey {
    case encryptedContent = "encrypted_content"
    case title
    case text
    case pageAge = "page_age"
    case type
    case url
  }
}
